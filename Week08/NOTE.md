## 第十六课 位运算

- 位运算符
  - 左移  <<
  - 右移  >>
  - 按位或 |、按位与 &、按位取反 ~、按位异或 ^

- XOR - 异或

  - 相同为0，不同为1
  - x ^ 0 = x
  - x ^ 1s = ~x
  - x ^ (~x) = 1s
  - x ^ x = 0

  - c = a ^ b => a ^ c = b, b ^ c = a    // 交换两个数


- 指定位置的位运算
  - 将 x 最右边的 n 位清零：x & (~0<<n)
    - x = 1001110、n = 3
    - ~0<<n = 1000、 1001110 & 1000 = 10001000
  - 获取 x 的第 n 位值（0 或者 1）： (x >>n) & 1
  - 获取 x 的第 n 位的幂值：x & (1 <<n)
  - 仅将第 n 位置为 1：x | (1 <<n)
  - 仅将第 n 位置为 0：x & (~ (1 <<n))
  - 将 x 最高位至第 n 位（含）清零：x & ((1 <<n) - 1)
  7. 将第 n 位至第 0 位（含）清零：x & (~ ((1 <<(n+ 1)) - 1))

- 实战位运算要点

  - 判断奇偶：
    - x % 2 == 1  <==> x & 1 == 1
    - x % 2 == 0  <==> x & 1 == 0
  - x >> 1  -->  x / 2
    - x = x / 2  <==>  x = x >> 1;
  - x = x & (x - 1) 清零最低位的1
    - x = 101100、x - 1 = 100011
    - 101100 & 100011 = 101000;

  - x & -x 得到最低位的1
  - x & ~x = 0

### 实战题目

- 位1的个数：https://leetcode-cn.com/problems/number-of-1-bits/
  - 解题思路：暴力循环计数、统计最低位的1（获取统计次数）

- 2的幂：https://leetcode-cn.com/problems/power-of-two/
  - 解题思路：位运算，二进制只有1个1

- 颠倒二进制位：https://leetcode-cn.com/problems/reverse-bits/
  - 解题思路：位运算，每次结果左移一位加上目标&1，更新目标右移一位
- 

## 第十七课 布隆过滤器 & LRU缓存

### 布隆过滤器

- Bloom Filter vs Hash Table

  一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索 一个元素是否在一个集合中。

  优点是空间效率和查询时间都远远超过一般的算法， 缺点是有一定的误识别率和删除困难。

  ![image-20200729232556031](/Users/luozhengqi/Library/Application Support/typora-user-images/image-20200729232556031.png)

- 使用场景：Redis、垃圾邮件、评论等的过滤

### LRU缓存

- 两个要素： 大小 、替换策略
-  Hash Table + Double LinkedList
-  O(1) 查询 O(1) 修改、更新

### 实战题目

- LRU缓存机制：https://leetcode-cn.com/problems/lru-cache/#/
  - 解题思路：双向链表 + hash表、手撸双向链表